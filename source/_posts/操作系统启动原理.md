---
title: 操作系统启动原理
author: 菠菜
top: false
cover: false
coverImg: 'https://source.unsplash.com/random'
toc: true
mathjax: true
tags:
  - 计算机操作系统
  - Linux内核
  - 系统启动
summary: 通过Linux0.11的源码理解操作系统的启动原理
categories: 计算机操作系统
abbrlink: 5057
date: 2020-04-13 09:35:49
---

### 整体执行过程

 在PC加电自检后，ROM-BIOS会把引导扇区代码bootsect加载到0x7C00处并执行，执行过程中bootsect把自己移到0x90000处。程序主要负责：

1）把从磁盘第2扇区开始的4个扇区的setup模块（setup.s生成）加载到内存0x90200处（此处为紧接着ROM-BIOS之后），加载后内存如下分布（第一扇区即存放bootsect.s）：

![](https://gitee.com/Laicize/images/raw/master/img/20200413150334.png)

2） 利用BIOS中断0x13取磁盘参数表中当前启动引导盘的参数

3） 屏幕显示“Loading system…”

4） 把磁盘setup模块后面的system模块加载到内存0x10000

5） 确定根文件系统设备号并保存其设备号于root_dev

6） 跳转到setup程序开始处（即0x90200）执行setup程序

> cs:程序的段基地址,ip偏移地址
>
> 物理地址=段基地址<<4+ip

### 引导扇区代码:bootsect.s

#### 执行bootsect过程中，bootsect把自己移到0x90000

```
armasm…
BOOTSEG  = 0x07c0                      ! original address of boot-sector
INITSEG  = 0x9000                         ! we move boot here - out of the way
…

entry _start
_start:
    mov  ax,#BOOTSEG    
    mov  ds,ax                             !ds寄存器置为0x07c0
    mov  ax,#INITSEG
    mov  es,ax                             !es寄存器置为0x9000
    mov  cx,#256                         !设置计数器，计数256
    sub    si,si                              
    sub    di,di                              !sub是做减法操作，此处将si，di自己减自己，即置0。
                                         !移动时源地址ds：si=0x07c0：0x0000，目的地址es：di=0x9000：0x0000
                                         !即将BIOS移动到0x9000（0x07c0用于放置bootsect.s）
    rep                       !rep指令作用：重复执行后面一句操作，并递减cx的值，直到cx=0停止
    movw                  !movw指令作用：这里从内存[si]处移动cx个字到[di]；注意一次的移动单位是“字”，mov指令+w（word）是一次移动一个字
   jmpi  go,INITSEG                 !将BIOS移动到0x9000后，跳转（go）到INITSEG（0x9000）
```

> 1. inter和AT&T的语法不同,mov指令,源操作数和目的操作数相反.
> 2. 将boosect从0x07c0移到0x90000

#### 	 把从磁盘第2扇区开始的4个扇区的setup模块（setup.s生成）加载到内存0x90200处	

#### 　　

```armasm
go:        mov  ax,cs //cs=ox9000
    mov  ds,ax
    mov  es,ax   !ds、es都置成移动后代码所在的段处（0x9000）
! put stack at 0x9ff00. 下面两条指令是将堆栈指针sp指向0x9ff00处（即0x9000:0xff00）
    mov  ss,ax  
   mov  sp,#0xFF00                  ! arbitrary value >>512
   load_setup:
    mov  dx,#0x0000                  ! drive 0, head 0  dx为0x0000，即dh为0x00，dl为0x00，即磁头号0，驱动器0
    mov  cx,#0x0002                   ! sector 2, track 0  同上磁道号0（低8位和高2位都是0）， 开始扇区为2（从cl的低5位得到）
  mov  bx,#0x0200                  ! address = 512, in INITSEG  数据缓冲区0x90200，注意前面es已设置为0x9000，设置bx为0x0200，即数据缓冲区为0x9000*10H+0x0200=0x90200
    mov  ax,#0x0200+SETUPLEN    ! service 2, nr of sectors SETUPLEN初始设置为4，这里0x0200+4，ah=0x02（读磁盘扇区到内存），al=4（即需要读出4个扇区）。
    int     0x13                    ! read it  打开中断
    jnc     ok_load_setup              ! ok – continue  jnc指令：如果（上条指令）成功，则跳转，即中断INT 0x13成功，则继续执行ok_load_setup
    mov  dx,#0x0000                  !如果不成功，则复位驱动器，并重试（重新跳转函数load_setup）
    mov  ax,#0x0000                   ! reset the diskette
    int     0x13
   j        load_setup
```

> 1. INT 0x13的使用方法：
>    ah = 0x20-读磁盘扇区到内存； al = 需要读出的扇区数量；
>    ch=磁道（柱面）号的低8位；  cl =开始扇区（位0-5），磁道号高2位（位6-7）；
>    dh = 磁头号；  dl = 驱动器号；
>    es：bx = 指向数据缓冲区； 
>    如果出错则CF标志置位，ah中是出错码。
>
> 2. 利用BIOS中断0x13取磁盘参数表中当前启动引导盘的参数
>
>    取磁盘驱动器参数，使用INT 0x13中断获得，格式如下：
>
>    AH=0x08 dl=驱动器号
>
>    其返回值为：
>
>    （1） 如果出错则CF置位，ah=状态码
>
>    （2） ah=0，al=0，bl=驱动器类型
>
>    （3） ch=最大磁道号低8位，cl=每磁道最大扇区数（0-5位），最大磁道号高2位（6-7位）
>
>    （4） dh=最大磁头数，dl=驱动器数量
>
>    （5） es:di 软驱磁盘参数表
>
>    ```armasm
>    mov      dl,#0x00              !驱动器号为0
>    mov      ax,#0x0800                   ! AH=8，是INT 0x13取磁盘驱动器的参数，AL初始化0，作为返回值
>    int         0x13                    !打开INT 0x13中断
>    mov      ch,#0x00
>    seg cs             !此条指令表示下一条语句的操作数在cs段寄存器所指的段中
>    ！软盘的最大磁道号不会超过256，ch返回最大磁道号低8位，已足够表示它，因此cl位6-7肯定为0，而前面语句ch已置0，说明cx的6-15位为0。
>    ！那么cx的0-5位会返回每磁道最大扇区数，即此时cx值是每磁道最大扇区数。
>    mov      sectors,cx 
>        … …
>    ```
>
>    如果想获得磁盘驱动器的参数，那么应该使用INT 0x13中断的返回值获得，设置初始值ah和dl的值，打开中断，即可。这段代码主要还是获得每磁道的扇区数量，保存在了sectors中。

#### 　   屏幕显示“Loading system…”

```armasm
! Print some inane message
! 显示信息：“'Loading system ...' 回车”，共显示24个字符
! 使用BIOS中断0x10功能号ah=0x03和ah=0x13实现
! 请仔细阅读中断的使用

! BIOS中断0x10功能号ah=0x03，功能：读光标位置
! 输入：bh=页号
! 返回：ch=扫描开始线；cl=扫描结束线；dh=行号； dl=列号

! BIOS中断0x10功能号ah=0x13，功能：显示字符串
! 输入：al=放置光标方式及规定属性。0x01表示使用bl中属性值，光标停在字符串结尾处；
!      es:bp 指向要显示的字符串起始位置。 cx=显示字符串个数； bh=显示页面号
!      bl=字符属性； dh=行号； dl=页号

         mov  ah,#0x03             !读光标
         xor    bh,bh                            ! xor代表异或，这条命令将bh置0
         int     0x10                    !返回行号和列号，供串口显示

         mov  cx,#24                           ! 显示24个字符
         mov  bx,#0x0007                  ! bh=0，页=0；bl=7，字符属性=7
         mov  bp,#msg1            ! es:bp寄存器指向要显示的字符串
         mov  ax,#0x1301                   ! ah=0x13使用中断0x10功能号；al=0x01，使用bl中属性值
         int     0x10                    !开中断，串口打印字符串
```

> 上面使用中断0x10显示字符，首先使用ah=0x03功能获取光标位置以及行号列号，作为ah=0x13中断的入参；而后使用ah=0x13中断将存在es:bp寄存器的字符串打印在串口屏幕，只要在使用中断时，将输入设定好即可。

#### 把磁盘setup模块后面的system模块加载到内存0x10000

```armasm
SYSSEG = 0x1000
…
       mov  ax, #SYSSEG    
       mov  es,ax           ! es寄存器存放system段地址
       call    read_it ! 调用read_it函数，读取磁盘上system模块，es为输入参数
       …
```

> read_it函数主要实现：
>
> （1）判断es值是否位于64KB地址边界，否，则进入死循环；
>
> （2）bx取异或操作，将bx置0，此时es:bx为0x1000:0x0000，即内存0x10000地址；
>
> （3）通过前面获取的每磁道扇区数，判断读取的扇区个数（system模块所占），即确定需要加载的system模块的开始地址和结束地址；
>
> （4）从system模块开始地址处读取数据到es:bx，期间不断判断是否读取到结尾处，如果是，则结束读取，否则继续读取。

#### 确定根文件系统设备号并保存其设备号于root_dev

```armasm
! Linux中，软驱的主设备号是2，次设备号=type*4+nr，其中nr为0-3分别对应软驱A、B、C和D；
！ type是软驱类型（2->1.2MB或7->1.44MB）。
！ 因为7*4+0=28，所以/dev/PS0 (2,28)指1.44MB A驱动器，其设备号是0x021c（2*256+28）
！ 同理，/dev/at0 (2,8)值1.2MB A驱动器，设备号是0x0208

! 取上面获得的每磁道扇区数，如果sectors=15说明是1.2MB的驱动器；如果sectors=18说明是1.44M软驱（为什么？）；
！因为是可引导的驱动器，所以肯定是A驱
seg cs
mov  ax,root_dev
cmp   ax,#0
jne     root_defined    ！检查root_dev是否是空，如果否，则说明其已经存入根设备号，直接跳转后面
seg cs
mov  bx,sectors
mov  ax,#0x0208                   ! /dev/ps0 - 1.2Mb
cmp   bx,#15
je       root_defined    ！将sectors与15对比，如果相同，则ax=0x0208，最终赋值给root_defined
mov  ax,#0x021c                   ! /dev/PS0 - 1.44Mb
cmp   bx,#18
je       root_defined    ！将sectors与18对比，如果相同，则ax=0x021c，最终赋值给root_defined
undef_root:
jmp undef_root
root_defined:
seg cs
mov  root_dev,ax   ！将获取的驱动设备号存入root_dev
jmpi 0,SETUPSEG ！SETUPSEG=0x9020 //跳转到setup程序开始处（即0x90200）执行setup程序
```

> 接下来要确定使用哪个根文件系统设备。开始判断，如果已经指定了设备（！=0），那么就使用给定的设备；否则就使用前面获取的每磁道扇区数来确定到底是使用/dev/PS0 (2,28)还是/dev/at0 (2,8)。但是不清楚“如果sectors=15说明是1.2MB的驱动器；如果sectors=18说明是1.44M软驱”这句话。

